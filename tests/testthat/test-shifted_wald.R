context("Shifted Wald")

test_that("rshifted_wald matches theoretical moments", {
  n_samples <- 15000
  set.seed(123)
  nu_values <- c(0.5, 1, 3, 5)
  alpha_values <- c(0.1, 0.5, 1, 2)
  ndt_values <- c(0, 0.1, 0.3, 0.5) # Keep ndt
  tol_mean <- 0.05
  tol_sd_abs <- 0.05 # Base absolute tolerance
  tol_sd_rel <- 0.15 # Relaxed relative tolerance component to 15%

  for (nu in nu_values) {
    for (alpha in alpha_values) {
      for (ndt in ndt_values) { # Keep ndt
        label <- sprintf("params(nu=%.1f, alpha=%.1f, ndt=%.1f)", nu, alpha, ndt) # Keep ndt
        rts <- rshifted_wald(n_samples, nu = nu, alpha = alpha, ndt = ndt) # Keep ndt

        if(any(is.na(rts))) {
            warning("NA values generated by rshifted_wald for ", label)
            next
        }

        theo_mean <- alpha / nu + ndt # Keep ndt
        theo_var <- alpha / (nu^3)
        theo_sd <- sqrt(theo_var)
        emp_mean <- mean(rts)
        emp_sd <- sd(rts)

        expect_equal(emp_mean, theo_mean, tolerance = tol_mean,
                     label = paste(label, "- Mean: Empirical vs Theoretical"))

        # Use a combined absolute and relaxed relative tolerance for SD
        current_tol_sd <- max(tol_sd_abs, theo_sd * tol_sd_rel)
        expect_equal(emp_sd, theo_sd, tolerance = current_tol_sd,
                     label = paste(label, "- SD: Empirical vs Theoretical"))
      }
    }
  }
})

test_that("dshifted_wald integrates correctly", {
  n_samples_for_range <- 5000
  set.seed(456)
  tol_integration <- 1e-3 # Relaxed tolerance

  nu_values <- c(0.8, 2, 4)
  alpha_values <- c(0.2, 0.7, 1.5)
  ndt_values <- c(0.05, 0.2, 0.4)

  for (nu in nu_values) {
    for (alpha in alpha_values) {
      for (ndt in ndt_values) {
        label <- sprintf("params(nu=%.1f, alpha=%.1f, ndt=%.1f)", nu, alpha, ndt)
        integrand <- function(x_int) {
          dshifted_wald(x_int, nu = nu, alpha = alpha, ndt = ndt)
        }
        x_sample_range <- rshifted_wald(n_samples_for_range, nu = nu, alpha = alpha, ndt = ndt)
        # Ensure sample range is valid before calculating quantiles/sd
         if(any(is.na(x_sample_range)) || length(x_sample_range) < 2) {
             warning("Skipping integration test for ", label, " due to invalid sample range.")
             next
         }
        upper_limit <- quantile(x_sample_range, 0.9999, na.rm = TRUE) + 10 * sd(x_sample_range, na.rm = TRUE) # Increased range capture
        if (!is.finite(upper_limit) || upper_limit < ndt + 10) upper_limit <- ndt + 100

        integral_result <- tryCatch(
          stats::integrate(integrand, lower = ndt + .Machine$double.eps, upper = upper_limit,
                           subdivisions = 1000, rel.tol = tol_integration/10, abs.tol = tol_integration/10)$value, # Increased subdivisions, tighter integrate tol
          error = function(e) {
            warning("Integration failed for ", label, ": ", e$message)
            NA
          }
        )

        if (!is.na(integral_result)) {
          expect_equal(integral_result, 1, tolerance = tol_integration, # Use relaxed test tolerance
                       label = paste(label, "- Density integrates to 1"))
        }
      }
    }
  }
})


test_that("pshifted_wald matches rshifted_wald and has correct properties", {
  n_samples <- 20000 # More samples for better ECDF accuracy
  set.seed(789)
  tol_cdf <- 0.05 # Tolerance for comparing pshifted_wald to ECDF

  nu_values <- c(0.8, 3)
  alpha_values <- c(0.3, 1.0)
  ndt_values <- c(0.1, 0.4)

  for (nu in nu_values) {
    for (alpha in alpha_values) {
      for (ndt in ndt_values) {
        label <- sprintf("params(nu=%.1f, alpha=%.1f, ndt=%.1f)", nu, alpha, ndt)

        # Generate samples
        rts <- rshifted_wald(n_samples, nu = nu, alpha = alpha, ndt = ndt)
        if(any(is.na(rts))) {
            warning("NA values generated by rshifted_wald for ", label)
            next
        }

        # Calculate empirical CDF
        ecdf_rts <- stats::ecdf(rts)

        # Test points (quantiles from empirical distribution)
        test_quantiles <- quantile(rts, probs = c(0.01, 0.1, 0.25, 0.5, 0.75, 0.9, 0.99), na.rm = TRUE)
        # Add edge cases near ndt
        test_quantiles <- c(ndt + 1e-6, ndt + 0.01, test_quantiles)
        test_quantiles <- unique(test_quantiles[is.finite(test_quantiles) & test_quantiles > ndt])

        # 1. Compare pshifted_wald with empirical CDF
        p_values <- pshifted_wald(test_quantiles, nu = nu, alpha = alpha, ndt = ndt)
        ecdf_values <- ecdf_rts(test_quantiles)
        expect_equal(p_values, ecdf_values, tolerance = tol_cdf,
                     label = paste(label, "- CDF: pshifted_wald vs Empirical"))

        # 2. Check boundary conditions
        expect_equal(pshifted_wald(ndt, nu = nu, alpha = alpha, ndt = ndt), 0,
                     label = paste(label, "- CDF at ndt is 0"))
        expect_equal(pshifted_wald(ndt - 1e-6, nu = nu, alpha = alpha, ndt = ndt), 0,
                     label = paste(label, "- CDF below ndt is 0"))
        expect_equal(pshifted_wald(Inf, nu = nu, alpha = alpha, ndt = ndt), 1,
                     label = paste(label, "- CDF at Inf is 1"))

        # 3. Check lower.tail argument
        p_upper <- pshifted_wald(test_quantiles, nu = nu, alpha = alpha, ndt = ndt, lower.tail = FALSE)
        expect_equal(p_upper, 1 - p_values, tolerance = 1e-7,
                     label = paste(label, "- CDF lower.tail=FALSE"))

        # 4. Check log.p argument
        p_log <- pshifted_wald(test_quantiles, nu = nu, alpha = alpha, ndt = ndt, log.p = TRUE)
        # Avoid log(0) issues for comparison by filtering p_values > 0
        valid_idx <- p_values > 0
        expect_equal(p_log[valid_idx], log(p_values[valid_idx]), tolerance = 1e-7,
                     label = paste(label, "- CDF log.p=TRUE"))
        # Check that where p_values is 0, log.p is -Inf
        expect_true(all(p_log[!valid_idx] == -Inf),
                    label = paste(label, "- CDF log.p=TRUE gives -Inf for p=0"))

      }
    }
  }
})



context("Shifted Wald - brms")



test_that("Shifted Wald model can recover parameters with brms", {

  skip_if_not_installed("brms")
  skip_if_not_installed("cmdstanr")

  set.seed(555)
  n_obs <- 200

  # True parameters
  true_mu <- 2.5
  true_alpha <- 0.8
  true_tau <- 0.8 # Proportion of minrt
  true_minrt <- 0.2 # Assume a fixed known minrt for simplicity here
  true_ndt <- true_tau * true_minrt

  # Simulate data
  df <- data.frame(rt = rshifted_wald(n_obs, nu = true_mu, alpha = true_alpha, ndt = true_ndt))

  # Define brms formula - simple intercept-only model
  # Note: We fix minrt here by passing it as data. tau is estimated.
  f <- brms::bf(rt ~ 1,
              mu ~ 1,
              alpha ~ 1,
              tau ~ 1,
              minrt = min(df$rt),
              family = shifted_wald())

  # Fit model using variational inference for speed
  fit <- brms::brm(f,
              data = df,
              stanvars = shifted_wald_stanvars(),
              backend = "cmdstanr",
              algorithm = "pathfinder", # VI
              refresh = 0)

  # Check results
  summary_fit <- summary(fit)
  fixed_effects <- summary_fit$fixed

  # Check recovery (comparing posterior mean to true value)
  # Note: Intercepts are on the link scale (log/logit)
  expect_equal(exp(fixed_effects["Intercept", "Estimate"]), true_mu, tolerance = 0.3, label = "mu recovery")
  expect_equal(fixed_effects["alpha_Intercept", "Estimate"], log(true_alpha), tolerance = 0.5, label = "alpha recovery")
  expect_equal(plogis(fixed_effects["tau_Intercept", "Estimate"]), true_tau, tolerance = 0.05, label = "tau recovery")
})


test_that("Stan shifted_wald_lpdf matches R dshifted_wald function", {
  skip_if_not_installed("cmdstanr")

  # Expose the Stan function
  shifted_wald_lpdf <- shifted_wald_lpdf_expose()

  # --- Test multiple valid parameter combinations using nested loops ---
  mu_vals    <- c(1.0, 3.0, 5.0)
  alpha_vals <- c(0.3, 0.8, 1.5)
  tau_vals   <- c(0.1, 0.5, 0.9)
  minrt_vals <- c(0.1, 0.25)
  y_offsets  <- c(0.05, 0.2, 1.0) # Values to add to ndt to get Y

  for (mu_val in mu_vals) {
    for (alpha_val in alpha_vals) {
      for (tau_val in tau_vals) {
        for (minrt_val in minrt_vals) {
          for (y_offset in y_offsets) {

            ndt_val <- tau_val * minrt_val
            y_val   <- ndt_val + y_offset # Ensure Y > ndt

            label <- sprintf("Valid case: mu=%.1f, alpha=%.1f, tau=%.1f, minrt=%.2f, Y=%.3f",
                             mu_val, alpha_val, tau_val, minrt_val, y_val)

            # Calculate R log-likelihood
            r_loglik <- dshifted_wald(y_val, nu = mu_val, alpha = alpha_val, ndt = ndt_val, log = TRUE)

            # Calculate Stan log-likelihood
            stan_loglik <- shifted_wald_lpdf(Y = y_val, mu = mu_val, alpha = alpha_val, tau = tau_val, minrt = minrt_val)

            # Compare
            expect_equal(stan_loglik, r_loglik, tolerance = 1e-6, label = label)
          }
        }
      }
    }
  }

  # --- Test specific edge cases and invalid inputs ---
  # Re-use one set of valid parameters for these tests
  mu_val <- 3.0; alpha_val <- 0.5; tau_val <- 0.5; minrt_val <- 0.4; ndt_val <- tau_val * minrt_val
  y_val <- ndt_val + 0.1 # Base Y for invalid tests

  # Case where Y < ndt
  y_below <- 0.15
  r_loglik_below <- dshifted_wald(y_below, nu = mu_val, alpha = alpha_val, ndt = ndt_val, log = TRUE)
  stan_loglik_below <- shifted_wald_lpdf(Y = y_below, mu = mu_val, alpha = alpha_val, tau = tau_val, minrt = minrt_val)
  expect_equal(stan_loglik_below, r_loglik_below, label = "Stan vs R: Y < ndt")
  expect_true(is.infinite(stan_loglik_below) && stan_loglik_below < 0)

  # Case where Y == ndt (edge case)
  y_equal <- ndt_val
  r_loglik_equal <- dshifted_wald(y_equal, nu = mu_val, alpha = alpha_val, ndt = ndt_val, log = TRUE)
  stan_loglik_equal <- shifted_wald_lpdf(Y = y_equal, mu = mu_val, alpha = alpha_val, tau = tau_val, minrt = minrt_val)
  expect_equal(stan_loglik_equal, r_loglik_equal, label = "Stan vs R: Y == ndt")
  expect_true(is.infinite(stan_loglik_equal) && stan_loglik_equal < 0)

  # Invalid mu
  stan_loglik_bad_mu <- shifted_wald_lpdf(Y = y_val, mu = -1.0, alpha = alpha_val, tau = tau_val, minrt = minrt_val)
  expect_equal(stan_loglik_bad_mu, -Inf, label = "Stan invalid mu")

  # Invalid alpha
  stan_loglik_bad_alpha <- shifted_wald_lpdf(Y = y_val, mu = mu_val, alpha = 0.0, tau = tau_val, minrt = minrt_val)
  expect_equal(stan_loglik_bad_alpha, -Inf, label = "Stan invalid alpha")

  # Invalid tau (< 0)
  stan_loglik_bad_tau1 <- shifted_wald_lpdf(Y = y_val, mu = mu_val, alpha = alpha_val, tau = -0.1, minrt = minrt_val)
  expect_equal(stan_loglik_bad_tau1, -Inf, label = "Stan invalid tau (<0)")

  # Invalid tau (> 1)
  stan_loglik_bad_tau2 <- shifted_wald_lpdf(Y = y_val, mu = mu_val, alpha = alpha_val, tau = 1.1, minrt = minrt_val)
  expect_equal(stan_loglik_bad_tau2, -Inf, label = "Stan invalid tau (>1)")

  # Edge case tau = 0
  ndt_zero <- 0.0 * minrt_val
  y_val_tau0 <- ndt_zero + 0.1 # Need a Y > ndt=0
  r_loglik_tau0 <- dshifted_wald(y_val_tau0, nu = mu_val, alpha = alpha_val, ndt = ndt_zero, log = TRUE)
  stan_loglik_tau0 <- shifted_wald_lpdf(Y = y_val_tau0, mu = mu_val, alpha = alpha_val, tau = 0.0, minrt = minrt_val)
  expect_equal(stan_loglik_tau0, r_loglik_tau0, tolerance = 1e-6, label = "Stan vs R: tau = 0")

  # Edge case tau = 1
  ndt_one <- 1.0 * minrt_val
  y_val_tau1 <- ndt_one + 0.1 # Need a Y > ndt
  r_loglik_tau1 <- dshifted_wald(y_val_tau1, nu = mu_val, alpha = alpha_val, ndt = ndt_one, log = TRUE)
  stan_loglik_tau1 <- shifted_wald_lpdf(Y = y_val_tau1, mu = mu_val, alpha = alpha_val, tau = 1.0, minrt = minrt_val)
  expect_equal(stan_loglik_tau1, r_loglik_tau1, tolerance = 1e-6, label = "Stan vs R: tau = 1")

})
