context("Single-Accumulator LBA")

test_that("rrt_lba produces valid reaction times and responds to parameters", {
  set.seed(123)
  n <- 10000  # Large sample size for reliable means

  # Parameter combinations for basic property tests
  param_combinations <- expand.grid(
    drift = c(1, 3),
    sigma = 1,
    sigmabias = 0.5,
    bs = 0.5,
    ndt = 0.3
  )

  # 1. Basic property tests
  for (i in 1:nrow(param_combinations)) {
    params <- param_combinations[i, ]
    label <- sprintf("params(drift=%.1f, sigma=%.1f, sigmabias=%.1f, bs=%.1f, ndt=%.1f)",
                     params$drift, params$sigma, params$sigmabias, params$bs, params$ndt)
    rts <- rrt_lba(n, drift = params$drift, sigma = params$sigma,
                   sigmabias = params$sigmabias, bs = params$bs, ndt = params$ndt)

    # Check for NA values
    if (any(is.na(rts))) {
      warning("NA values generated by rrt_lba for ", label)
      next
    }

    # All RTs should be >= ndt
    expect_true(all(rts >= params$ndt),
                label = paste(label, "- All RTs >= ndt"))

    # All RTs should be finite
    expect_true(all(is.finite(rts)),
                label = paste(label, "- All RTs are finite"))
  }

  # 2. Parameter sensitivity tests
  # Effect of drift: higher drift should decrease mean RT
  params_low_drift <- list(drift = 1, sigma = 1, sigmabias = 0.5, bs = 0.5, ndt = 0.3)
  params_high_drift <- list(drift = 3, sigma = 1, sigmabias = 0.5, bs = 0.5, ndt = 0.3)

  rts_low_drift <- rrt_lba(n, drift = params_low_drift$drift, sigma = params_low_drift$sigma,
                           sigmabias = params_low_drift$sigmabias, bs = params_low_drift$bs,
                           ndt = params_low_drift$ndt)
  rts_high_drift <- rrt_lba(n, drift = params_high_drift$drift, sigma = params_high_drift$sigma,
                            sigmabias = params_high_drift$sigmabias, bs = params_high_drift$bs,
                            ndt = params_high_drift$ndt)

  mean_low_drift <- mean(rts_low_drift)
  mean_high_drift <- mean(rts_high_drift)

  expect_true(mean_high_drift < mean_low_drift,
              label = "Mean RT decreases with increasing drift")

  # Effect of bs: higher bs should increase mean RT
  params_low_bs <- list(drift = 3, sigma = 1, sigmabias = 0.5, bs = 0.5, ndt = 0.3)
  params_high_bs <- list(drift = 3, sigma = 1, sigmabias = 0.5, bs = 1, ndt = 0.3)

  rts_low_bs <- rrt_lba(n, drift = params_low_bs$drift, sigma = params_low_bs$sigma,
                        sigmabias = params_low_bs$sigmabias, bs = params_low_bs$bs,
                        ndt = params_low_bs$ndt)
  rts_high_bs <- rrt_lba(n, drift = params_high_bs$drift, sigma = params_high_bs$sigma,
                         sigmabias = params_high_bs$sigmabias, bs = params_high_bs$bs,
                         ndt = params_high_bs$ndt)

  mean_low_bs <- mean(rts_low_bs)
  mean_high_bs <- mean(rts_high_bs)

  expect_true(mean_high_bs > mean_low_bs,
              label = "Mean RT increases with increasing bs")
})



test_that("drt_lba integrates correctly and returns valid densities", {
  set.seed(456)
  n_samples_for_range <- 5000
  tol_integration <- 1e-3  # Tolerance for integration

  # Parameter combinations
  param_combinations <- expand.grid(
    drift = c(1, 3),
    sigma = c(0.5, 1),
    sigmabias = c(0.2, 0.5),
    bs = 0.5,
    ndt = 0.3
  )

  # 1. Integration test
  for (i in 1:nrow(param_combinations)) {
    params <- param_combinations[i, ]
    label <- sprintf("params(drift=%.1f, sigma=%.1f, sigmabias=%.1f, bs=%.1f, ndt=%.1f)",
                     params$drift, params$sigma, params$sigmabias, params$bs, params$ndt)

    # Define the integrand
    integrand <- function(x) {
      drt_lba(x, drift = params$drift, sigma = params$sigma,
              sigmabias = params$sigmabias, bs = params$bs, ndt = params$ndt)
    }

    # Determine integration upper limit using simulated RTs
    x_sample_range <- rrt_lba(n_samples_for_range, drift = params$drift,
                              sigma = params$sigma, sigmabias = params$sigmabias,
                              bs = params$bs, ndt = params$ndt)
    if (any(is.na(x_sample_range)) || length(x_sample_range) < 2) {
      warning("Skipping integration test for ", label, " due to invalid sample range.")
      next
    }
    upper_limit <- quantile(x_sample_range, 0.9999, na.rm = TRUE) +
      10 * sd(x_sample_range, na.rm = TRUE)
    if (!is.finite(upper_limit) || upper_limit < params$ndt + 10) {
      upper_limit <- params$ndt + 100
    }

    # Compute the integral
    integral_result <- tryCatch(
      stats::integrate(integrand, lower = params$ndt + .Machine$double.eps,
                       upper = upper_limit, subdivisions = 1000,
                       rel.tol = tol_integration / 10, abs.tol = tol_integration / 10)$value,
      error = function(e) {
        warning("Integration failed for ", label, ": ", e$message)
        NA
      }
    )

    if (!is.na(integral_result)) {
      expect_equal(integral_result, 1, tolerance = tol_integration,
                   label = paste(label, "- Density integrates to 1"))
    }
  }

  # 2. Density value tests with a single parameter set
  params <- list(drift = 3, sigma = 1, sigmabias = 0.5, bs = 0.5, ndt = 0.3)
  rt_below_ndt <- params$ndt - 0.1
  rt_at_ndt <- params$ndt
  rt_above_ndt <- params$ndt + 0.5

  # Density should be 0 for RT < ndt
  expect_equal(drt_lba(rt_below_ndt, drift = params$drift, sigma = params$sigma,
                       sigmabias = params$sigmabias, bs = params$bs, ndt = params$ndt),
               0, label = "Density is 0 for RT < ndt")

  # Density should be non-negative at RT = ndt
  density_at_ndt <- drt_lba(rt_at_ndt, drift = params$drift, sigma = params$sigma,
                            sigmabias = params$sigmabias, bs = params$bs, ndt = params$ndt)
  expect_true(density_at_ndt >= 0,
              label = "Density is non-negative at RT = ndt")

  # Density should be non-negative for RT > ndt
  density_above_ndt <- drt_lba(rt_above_ndt, drift = params$drift, sigma = params$sigma,
                               sigmabias = params$sigmabias, bs = params$bs, ndt = params$ndt)
  expect_true(density_above_ndt >= 0,
              label = "Density is non-negative for RT > ndt")
})



context("Single-Accumulator LBA - brms")

test_that("lba model can recover parameters with brms", {
  # Skip on CRAN and when not running full tests
  skip_on_cran()
  skip_if_not_installed("brms")
  skip_if_not_installed("cmdstanr")

  set.seed(1234)

  # Generate synthetic data using our new LBA parametrization.
  # True parameters:
  n <- 4000
  true_drift <- 4             # mean drift for accumulator 0 (named mu in Stan)
  true_sigma <- 1      # sd for accumulator 0
  true_sigmabias <- 0.5      # starting-point range (A = sigmabias)
  true_bs <- 0.3             # threshold offset (b = sigmabias + bs)
  true_tau <- 0.8            # non-decision time
  true_minrt <- 0.2

  # Generate data using our simulation function rlba()
  df <- data.frame(rt = rrt_lba(n,
             drift = true_drift,
             sigma = true_sigma,
             sigmabias = true_sigmabias,
             bs = true_bs,
             ndt = true_minrt * true_tau))


  df <- df[df$rt < 1, , drop = FALSE]
  # hist(df$rt, breaks = 100)

  # We now specify the brms formula using the new parameters:
  f <- brms::bf(
    rt ~ 1,
    sigma = 1,
    sigmabias ~ 1,
    bs ~ 1,
    tau ~ 1,
    minrt = true_minrt,  # min(df$rt)
    family = rt_lba()
  )

  priors <- c(
    brms::set_prior("normal(0, 1)", class = "Intercept", dpar = "tau"),
    # brms::set_prior("normal(1, 0.1)", class = "Intercept", dpar = "sigma"),
    brms::set_prior("normal(3, 1)", class = "Intercept", dpar = ""),
    brms::set_prior("normal(0, 1)", class = "Intercept", dpar = "sigmabias")) |>
    brms::validate_prior(f, data = df)

  # Fit the model in brms with our custom family lba() and stanvars lba_stanvars()
  fit <- brms::brm(
    formula = f,
    data = df,
    prior = priors,
    stanvars = rt_lba_stanvars(), # our custom Stan functions (that include lba_lpdf)
    init = 0,
    # iter = 1000,
    # chains = 1,
    algorithm = "pathfinder",  # or "sampling"
    refresh = 0,
    backend = "cmdstanr"
  )

  # Extract posterior means from summary
  post <- brms::posterior_summary(fit)
  means <- post[, "Estimate"]

  # Check parameter recovery.
  est_drift <- log1p(exp(means[["b_Intercept"]]))
  expect_equal(est_drift, true_drift, tolerance = 0.15, label = "drift recovery")
  # est_sigmazero <- log1p(exp(means[["b_sigma_Intercept"]]))
  # expect_equal(est_sigmazero, true_sigma, tolerance = 0.15, label = "sigma recovery")
  est_sigmabias <- log1p(exp(means[["b_sigmabias_Intercept"]]))
  expect_equal(est_sigmabias, true_sigmabias, tolerance = 0.15, label = "sigmabias recovery")
  est_bs <- log1p(exp(means[["b_bs_Intercept"]]))
  expect_equal(est_bs, true_bs, tolerance = 0.15, label = "bs recovery")
  expect_equal(plogis(means[["b_tau_Intercept"]]), true_tau, tolerance = 0.15, label = "tau recovery")

  # --- Test Post-processing Functions ---
  # Test posterior prediction
  n_pred_draws <- 10
  newdata_pred <- df[1:5, ]
  pred <- brms::posterior_predict(fit, ndraws = n_pred_draws, newdata = newdata_pred)
  expect_true(is.matrix(pred))
  expect_equal(nrow(pred), n_pred_draws)
  # Here we assume prediction returns a matrix with reaction time predictions.
  # Check that predicted reaction times are greater than ndt (approximately)
  pred_rt <- pred[, seq(1, ncol(pred), by = 2)]
  expect_true(all(pred_rt > 0.9 * true_minrt), "Predicted RTs should generally exceed ndt")

  # Test log-likelihood calculation
  ll <- brms::log_lik(fit, ndraws = 5)
  expect_true(is.matrix(ll))
  expect_equal(nrow(ll), 5)
  expect_equal(ncol(ll), nrow(df))
  expect_true(all(is.finite(ll)), "Log-likelihood values should be finite")
})


test_that("Stan rt_lba_lpdf matches R rt_dlba", {
  skip_on_cran()
  skip_if_not_installed("cmdstanr")

  # Expose the Stan LPDF function for the one-accumulator model.
  rt_lba_lpdf_stan <- rt_lba_lpdf_expose()  # This should return a function

  # Define grids for testing.
  Y_values         <- c(0.3, 0.5, 0.8, 1.2, 2.0)
  drift_values     <- c(1, 3)             # Use only positive drift values
  sigma_values     <- c(0.5, 1)
  sigmabias_values <- c(0.5, 1.0)         # A = sigmabias
  bs_values        <- c(0.2, 0.5)           # b = sigmabias + bs
  tau_values       <- c(0.5, 0.8)
  min_rt           <- 0.2

  # Loop over each combination.
  for (drift in drift_values) {
    for (sigma in sigma_values) {
      for (sigmabias in sigmabias_values) {
        for (bs in bs_values) {
          for (tau in tau_values) {
            for (Y in Y_values) {
              ndt <- min_rt * tau

              # Only test RT values which are safely above ndt.
              if (Y <= ndt + 1e-9) next

              # Pass the signal-to-noise ratio into the Stan LPDF
              stan_lpdf <- rt_lba_lpdf_stan(Y, drift, sigma, sigmabias, bs, tau, min_rt)
              r_lpdf    <- drt_lba(Y, drift = drift, sigma = sigma,
                                   sigmabias = sigmabias, bs = bs, ndt = ndt, log = TRUE)

              label <- sprintf("Y=%.2f, drift=%.1f, sigma=%.1f, A=%.1f, bs=%.1f, ndt=%.2f",
                               Y, drift, sigma, sigmabias, bs, ndt)
              expect_equal(stan_lpdf, r_lpdf, tolerance = 0.1,
                           label = paste("Density mismatch:", label))
            }

            # Test RT values below ndt (should yield -Inf in both implementations).
            Y_below <- ndt - 0.01
            if (Y_below > 0) {
              stan_lpdf_below <- rt_lba_lpdf_stan(Y_below, drift, sigma, sigmabias, bs, tau, min_rt)
              r_lpdf_below    <- drt_lba(Y_below, drift = drift, sigma = sigma,
                                         sigmabias = sigmabias, bs = bs, ndt = ndt, log = TRUE)
              expect_equal(stan_lpdf_below, r_lpdf_below,
                           label = sprintf("Below ndt mismatch: Y=%.2f, ndt=%.2f", Y_below, ndt))
              expect_equal(stan_lpdf_below, -Inf,
                           label = sprintf("Should be -Inf when Y < ndt: Y=%.2f, ndt=%.2f", Y_below, ndt))
            }
          }
        }
      }
    }
  }
})
