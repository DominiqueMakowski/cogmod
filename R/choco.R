#' @title Choice-Confidence (CHOCO) Model
#'
#' @description
#' Simulates data from the Choice-Confidence (CHOCO) model. This model is useful for
#' subjective ratings (e.g., Likert-type scales) where responses represent a choice
#' between two underlying categories (e.g., "disagree" vs. "agree") along with a
#' degree of confidence or intensity.
#'
#' The CHOCO model divides the response scale at a middle-value. Responses above and below the
#' middle are modeled by two rescaled (and mirrored for the left side) [Beta-Gate][rbetagate()] distributions.
#' In Beta-Gate distributions, extreme values (0 or 1) are generated by the "lumping" of values
#' that crossed a threshold (or "gate"). The location of these gates from the center of the 
#' distribution is controlled by the `pex` and `bex` parameters, influecing the ease of crossing 
#' the gate (and thus the probability of extreme values).
#'
#' @param n Number of simulated trials.
#' @param p Proportion parameter determining the balance between the left and right sides
#'   *after excluding* the probability mass at the middle (`pmid`). `P(Right Side | Not Middle) = p`.
#' @param confright,confleft Mean parameter (`mu`) for the underlying Beta-Gate distribution for the 
#'   *right* side and *left* side, respectively. Represents confidence towards 1. `0 < confright < 1`.
#' @param precright,precleft Precision parameter (`phi`) for the underlying Beta-Gate distribution for 
#'   the *right* side and *left* side, respectively. Must be positive. Higher values indicate more 
#'   concentrated distributions, and a value of 1 corresponds to a uniform distribution.
#' @inheritParams rbetagate
#' @param pmid Probability mass exactly at the `mid`. This determines the proportion
#'   of trials where the output is directly assigned the value of `mid`, bypassing
#'   the left or right components.
#' @param mid The point dividing the scale (`0 < mid < 1`). Typically set to 0.5. Note that in the Stan implementation,
#'  `mid` is fixed at 0.5 and not available as a parameter. 
#'
#' @seealso rbetagate
#'
#' @details
#' **Psychological Interpretation:**
#' - `p`: Represents the overall tendency to choose the "right" category (e.g., "agree") over the "left"
#'   category (e.g., "disagree"), given that a choice is made (i.e., not responding exactly at `mid`).
#' - `confright` and `confleft`: Average confidence level when choosing the "right" or "left" category. 
#'   Higher values (closer to 1) indicate stronger confidence or agreement towards the extreme end of the 
#'   scale.
#' - `precright` and `precleft`: Certainty or consistency of the confidence ratings for the right and left
#'   choices, respectively. Higher values indicate less variability in confidence ratings around their
#'   respective means (`confright`, `confleft`).
#' - `pex`: Represents the overall tendency towards extreme responding (choosing 0 or 1).
#'   This could reflect individual response styles (e.g., acquiescence, yea-saying/nay-saying)
#'   or properties of the item itself (e.g., polarizing questions).
#' - `bex`: Indicates the *direction* of the extreme response bias. `bex > 0.5` suggests a bias
#'   for producing ones more easily, while `bex < 0.5` suggests a bias towards zero.
#'
#' @references
#' - Kubinec, R. (2023). Ordered beta regression: a parsimonious, well-fitting model for continuous data with
#'     lower and upper bounds. Political Analysis, 31(4), 519-536. (Describes the underlying ordered beta model)
#'
#' @examples
#' # Simulate data with different parameterizations
#' # 10% at mid, 50/50 split otherwise, symmetric confidence/precision
#' x1 <- rchoco(n=5000, p = 0.5, confright = 0.5, precright = 4,
#'   confleft = 0.5, precleft = 4, pex = 0.1, bex = 0.5, pmid = 0, mid = 0.5)
#' # hist(x1, breaks = 50, main = "CHOCO: Symmetric Confidence/Precision", xlab = "y")
#'
#' # No mid mass, 70% probability on right, higher confidence left (closer to 0)
#' x2 <- rchoco(n=5000, p = 0.7, confright = 0.5, precright = 3,
#'   confleft = 0.8, precleft = 5, pex = 0.15, bex = 0.7, pmid = 0, mid = 0.5)
#' # hist(x2, breaks = 50, main = "CHOCO: Asymmetric p, Higher Conf Left", xlab = "y")
#'
#' # Lower confidence overall (closer to mid), high probability in the middle
#' x3 <- rchoco(n=5000, p = 0.5, confright = 0.2, precright = 3,
#'   confleft = 0.2, precleft = 3, pex = 0, bex = 0.5, pmid = 0.05, mid = 0.5)
#' # hist(x3, breaks = 50, main = "CHOCO: Low confidence overall", xlab = "y")
#' @rdname rchoco
#' @export
rchoco <- function(n,
                   p = 0.5,
                   confright = 0.5,
                   precright = 4,
                   confleft = 0.5,
                   precleft = 4,
                   pex = 0.1,
                   bex = 0.5,
                   pmid = 0,
                   mid = 0.5) {

  # --- Input Validation ---
  if (any(n <= 0 | n != floor(n))) stop("n must be a positive integer.")
  if (any(mid <= 0 | mid >= 1)) stop("mid must be between 0 and 1 (exclusive).")
  if (any(pex < 0 | pex > 1)) stop("pex must be between 0 and 1.")
  if (any(bex < 0 | bex > 1)) stop("bex must be between 0 and 1.")
  if (any(p < 0 | p > 1)) stop("p must be between 0 and 1.")
  if (any(pmid < 0 | pmid > 1)) stop("pmid must be between 0 and 1.")
  if (any(confright <= 0 | confright >= 1)) stop("confright must be between 0 and 1 (exclusive).")
  if (any(precright <= 0)) stop("precright must be positive.")
  if (any(confleft <= 0 | confleft >= 1)) stop("confleft must be between 0 and 1 (exclusive).")
  if (any(precleft <= 0)) stop("precleft must be positive.")

  # Recycle
  n_out <- n
  p         <- rep(p,         length.out = n_out) 
  pex       <- rep(pex,       length.out = n_out)
  bex       <- rep(bex,       length.out = n_out)
  pmid      <- rep(pmid,      length.out = n_out)
  mid       <- rep(mid,       length.out = n_out)
  confright <- rep(confright, length.out = n_out)
  precright <- rep(precright, length.out = n_out)
  confleft  <- rep(confleft,  length.out = n_out)
  precleft  <- rep(precleft,  length.out = n_out)

  # Side probs
  prob_not_mid  <- 1 - pmid
  prob_left     <- prob_not_mid * (1 - p)

  # Underlying Beta-Gate params
  mu_right  <- confright
  phi_right <- precright
  mu_left   <- 1 - confleft
  phi_left  <- precleft
  pex_right <- pex * bex
  pex_left  <- pex * (1 - bex)

  # Draw side
  u <- stats::runif(n_out)
  out <- numeric(n_out)
  is_mid   <- u < pmid
  is_left  <- !is_mid & (u < pmid + prob_left)
  is_right <- !(is_mid | is_left)  # Remaining are right  

  # Assign mid
  out[is_mid] <- mid[is_mid]


  # Left component: draw from Beta-Gate on [0,1] then scale to [0,mid]
  idxleft <- which(is_left)
  n_left <- length(idxleft) # Store length
  if(n_left > 0){ # Check if > 0 instead of just length()
    yleft <- rbetagate(n_left, # Pass calculated n_left
                       mu = mu_left[idxleft], phi = phi_left[idxleft],
                       pex = pex_left[idxleft], bex = 0)
    out[idxleft] <- yleft * mid[idxleft]
  }

  # Right component: draw from Beta-Gate on [0,1] then scale to [mid,1]
  idxright <- which(is_right)
  n_right <- length(idxright) # Store length
  if(n_right > 0){ # Check if > 0
    yright <- rbetagate(n_right, # Pass calculated n_right
                        mu = mu_right[idxright], phi = phi_right[idxright],
                        pex = pex_right[idxright], bex = 1)
    out[idxright] <- mid[idxright] + yright * (1 - mid[idxright])
  }

  out
}

# Density function
#' @rdname rchoco
#' @export
dchoco <- function(x,
                    p = 0.5,
                    confright = 0.5,
                    precright = 4,
                    confleft = 0.5,
                    precleft = 4,
                    pex = 0.1,
                    bex = 0.5,
                    pmid = 0,
                    mid = 0.5,
                    log = FALSE) {

  # Input validation with warnings
  if (any(p < 0 | p > 1)) stop("p must be between 0 and 1")
  if (any(confright <= 0 | confright >= 1)) stop("confright must be between 0 and 1")
  if (any(precright <= 0)) stop("precright must be positive")
  if (any(confleft <= 0 | confleft >= 1)) stop("confleft must be between 0 and 1")
  if (any(precleft <= 0)) stop("precleft must be positive")
  if (any(pex < 0 | pex > 1)) stop("pex must be between 0 and 1")
  if (any(bex < 0 | bex > 1)) stop("bex must be between 0 and 1")
  if (any(pmid < 0 | pmid > 1)) stop("pmid must be between 0 and 1")
  if (any(mid <= 0 | mid >= 1)) stop("mid must be between 0 and 1 (exclusive)")
  if (any(x < 0 | x > 1)) warning("x must be between 0 and 1")

  # Input & recycle
  x <- as.numeric(x)
  n <- length(x)
  p         <- rep(p,         n)
  pex       <- rep(pex,       n)
  bex       <- rep(bex,       n)
  pmid      <- rep(pmid,      n)
  mid       <- rep(mid,       n)
  confright <- rep(confright, n)
  precright <- rep(precright, n)
  confleft  <- rep(confleft,  n)
  precleft  <- rep(precleft,  n)
  eps <- 1e-10 # Define a small tolerance

  # Side probs
  prob_not_mid <- 1 - pmid
  prob_left    <- prob_not_mid * (1 - p)
  prob_right   <- prob_not_mid * p

  # Underlying Beta-Gate params
  mu_right  <- confright
  phi_right <- precright
  mu_left   <- 1 - confleft
  phi_left  <- precleft
  pex_right <- pex * bex
  pex_left  <- pex * (1 - bex)

  # Initialize density
  dens <- numeric(n)

  # Off support
  dens[x < -eps | x > 1 + eps] <- 0

  # Point-mass at mid
  idx_mid <- which(abs(x - mid) < eps)
  if(length(idx_mid)) dens[idx_mid] <- pmid[idx_mid]

  # Point-mass at 0 and 1
  idx0 <- which(abs(x - 0) < eps)
  if(length(idx0)){
    mass0 <- dbetagate(0,
                       mu = mu_left[idx0], phi = phi_left[idx0],
                       pex = pex_left[idx0], bex = 0)
    dens[idx0] <- prob_left[idx0] * mass0
  }
  idx1 <- which(abs(x - 1) < eps)
  if(length(idx1)){
    mass1 <- dbetagate(1,
                       mu = mu_right[idx1], phi = phi_right[idx1],
                       pex = pex_right[idx1], bex = 1)
    dens[idx1] <- prob_right[idx1] * mass1
  }

  # Continuous left part
  idxleft <- which(x > eps & x < mid - eps)
  if(length(idxleft)){
    yleft <- x[idxleft] / mid[idxleft]
    fleft <- dbetagate(yleft,
                       mu = mu_left[idxleft], phi = phi_left[idxleft],
                       pex = pex_left[idxleft], bex = 0)
    dens[idxleft] <- prob_left[idxleft] * fleft / mid[idxleft]
  }

  # Continuous right part
  idxright <- which(x > mid + eps & x < 1 - eps)
  if(length(idxright)){
    yright <- (x[idxright] - mid[idxright]) / (1 - mid[idxright])
    fright <- dbetagate(yright,
                        mu = mu_right[idxright], phi = phi_right[idxright],
                        pex = pex_right[idxright], bex = 1)
    dens[idxright] <- prob_right[idxright] * fright / (1 - mid[idxright])
  }

  # Return log-density if requested
  if(log) dens <- ifelse(dens > 0, log(dens), -Inf)
  dens
}
